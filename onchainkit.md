# Learn to Build Smart Contracts and Onchain Apps

> Base Learn is a comprehensive, free guide to learning smart contract and onchain app development.

<Frame>
    <img src="https://mintcdn.com/base-a060aa97/gS084HRa38b8UMsN/images/learn/welcome/Base_Learn_Hero.png?fit=max&auto=format&n=gS084HRa38b8UMsN&q=85&s=f65f6acc0ea16d180dff8cae91296a9a" alt="Welcome" data-og-width="720" width="720" data-og-height="405" height="405" data-path="images/learn/welcome/Base_Learn_Hero.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/base-a060aa97/gS084HRa38b8UMsN/images/learn/welcome/Base_Learn_Hero.png?w=280&fit=max&auto=format&n=gS084HRa38b8UMsN&q=85&s=11b66f08233a068573f297bf3f89db35 280w, https://mintcdn.com/base-a060aa97/gS084HRa38b8UMsN/images/learn/welcome/Base_Learn_Hero.png?w=560&fit=max&auto=format&n=gS084HRa38b8UMsN&q=85&s=e23cd44423c0e1aac7031d437cfc779a 560w, https://mintcdn.com/base-a060aa97/gS084HRa38b8UMsN/images/learn/welcome/Base_Learn_Hero.png?w=840&fit=max&auto=format&n=gS084HRa38b8UMsN&q=85&s=a75052ad09a38910a608445cadf9dd55 840w, https://mintcdn.com/base-a060aa97/gS084HRa38b8UMsN/images/learn/welcome/Base_Learn_Hero.png?w=1100&fit=max&auto=format&n=gS084HRa38b8UMsN&q=85&s=31463b587f70df055b8ba6b48bae8f18 1100w, https://mintcdn.com/base-a060aa97/gS084HRa38b8UMsN/images/learn/welcome/Base_Learn_Hero.png?w=1650&fit=max&auto=format&n=gS084HRa38b8UMsN&q=85&s=cb301e19b068de1ba05d9bd1d391c49f 1650w, https://mintcdn.com/base-a060aa97/gS084HRa38b8UMsN/images/learn/welcome/Base_Learn_Hero.png?w=2500&fit=max&auto=format&n=gS084HRa38b8UMsN&q=85&s=919c30d3ca0e3f6bb846d998641d10cc 2500w" />
</Frame>

## Introduction

Welcome to Base Learn, your guide to learning smart contract development. Base Learn's curriculum has been expertly crafted to equip you with the skills and knowledge needed to build and deploy smart contracts on Base, or any EVM-compatible chain, including Ethereum, Optimism, and many more. Plus, you'll be eligible to earn NFTs as you complete each module, showcasing your mastery of the material.

Whether you're a curious novice or a seasoned pro looking to stay ahead of the game, our dynamic lessons cater to all levels of experience. You can start with the basics and work your way up, or dive straight into the more advanced concepts and push your limits to new heights.

Begin your journey today!

## What you can learn in this program

Base Learn covers the following topics. If you're looking for quickstarts, or deeper guides on advanced topics, check out our [Base Builder Tutorials](/)!

### [Ethereum Applications](/learn/introduction-to-ethereum/ethereum-applications)

* Describe the origin and goals of the Ethereum blockchain
* List common types of applications that can be developed with the Ethereum blockchain
* Compare and contrast Web2 vs. Web3 development
* Compare and contrast the concept of "ownership" in Web2 vs. Web3

### [Gas Use in Ethereum Transactions](/learn/introduction-to-ethereum/gas-use-in-eth-transactions)

* Explain what gas is in Ethereum
* Explain why gas is necessary in Ethereum
* Understand how gas works in Ethereum transactions

### [EVM Diagram](/learn/introduction-to-ethereum/evm-diagram)

* Diagram the EVM

### [Setup and Overview](/learn/hardhat/hardhat-setup-overview/hardhat-setup-overview-sbs)

* Install and create a new Hardhat project with Typescript support
* Describe the organization and folder structure of a Hardhat project
* List the use and properties of hardhat.config.ts

### [Testing with Hardhat and Typechain](/learn/hardhat/hardhat-testing/hardhat-testing-sbs)

* Set up TypeChain to enable testing
* Write unit tests for smart contracts using Mocha, Chai, and the Hardhat Toolkit
* Set up multiple signers and call smart contract functions with different signers

### [Etherscan](/learn/hardhat/etherscan/etherscan-sbs)

* List some of the features of Etherscan
* Read data from the Bored Ape Yacht Club contract on Etherscan
* Write data to a contract using Etherscan.

### [Deploying Smart Contracts](/learn/hardhat/hardhat-deploy/hardhat-deploy-sbs)

* Deploy a smart contract to the Base Sepolia Testnet with hardhat-deploy
* Deploy a smart contract to the Sepolia Testnet with hardhat-deploy
* Use BaseScan to view a deployed smart contract

### [Verifying Smart Contracts](/learn/hardhat/hardhat-verify/hardhat-verify-sbs)

* Verify a deployed smart contract on Etherscan
* Connect a wallet to a contract in Etherscan
* Use etherscan to interact with your own deployed contract

### [Hardhat Forking](/learn/hardhat/hardhat-forking/hardhat-forking)

* Use Hardhat Network to create a local fork of mainnet and deploy a contract to it
* Utilize Hardhat forking features to configure the fork for several use cases

### ['Introduction to Remix'](/learn/introduction-to-solidity/introduction-to-remix)

* List the features, pros, and cons of using Remix as an IDE
* Deploy and test the Storage.sol demo contract in Remix

### [Deployment in Remix](/learn/introduction-to-solidity/deployment-in-remix)

* Deploy and test the Storage.sol demo contract in Remix

### [Hello World](/learn/contracts-and-basic-functions/hello-world-step-by-step)

* Construct a simple "Hello World" contract
* List the major differences between data types in Solidity as compared to other languages
* Select the appropriate visibility for a function

### [Basic Types](/learn/contracts-and-basic-functions/basic-types)

* Categorize basic data types
* List the major differences between data types in Solidity as compared to other languages
* Compare and contrast signed and unsigned integers

### [Test Networks](/learn/deployment-to-testnet/test-networks)

* Describe the uses and properties of the Base testnet
* Compare and contrast Ropsten, Rinkeby, Goerli, and Sepolia

### [Deployment to Base Sepolia](/learn/deployment-to-testnet/deployment-to-base-sepolia-sbs)

* Deploy a contract to the Base Sepolia testnet and interact with it in \[BaseScan]

### [Contract Verification](/learn/deployment-to-testnet/contract-verification-sbs)

* Verify a contract on the Base Sepolia testnet and interact with it in \[BaseScan]

### [Control Structures](/learn/control-structures/control-structures)

* Control code flow with `if`, `else`, `while`, and `for`
* List the unique constraints for control flow in Solidity
* Utilize `require` to write a function that can only be used when a variable is set to `true`
* Write a `revert` statement to abort execution of a function in a specific state
* Utilize `error` to control flow more efficiently than with `require`

### [Storing Data](/learn/storage/simple-storage-sbs)

* Use the constructor to initialize a variable
* Access the data in a public variable with the automatically generated getter
* Order variable declarations to use storage efficiently

### [How Storage Works](/learn/storage/how-storage-works)

* Diagram how a contract's data is stored on the blockchain (Contract -> Blockchain)
* Order variable declarations to use storage efficiently
* Diagram how variables in a contract are stored (Variable -> Contract)

### [Arrays](/learn/arrays/arrays-in-solidity)

* Describe the difference between storage, memory, and calldata arrays

### [Filtering an Array](/learn/arrays/filtering-an-array-sbs)

* Write a function that can return a filtered subset of an array

### [Mappings](/learn/mappings/mappings-sbs)

* Construct a Map (dictionary) data type
* Recall that assignment of the Map data type is not as flexible as for other data types/in other languages
* Restrict function calls with the `msg.sender` global variable
* Recall that there is no collision protection in the EVM and why this is (probably) ok

### [Function Visibility and State Mutability](/learn/advanced-functions/function-visibility)

* Categorize functions as public, private, internal, or external based on their usage
* Describe how pure and view functions are different than functions that modify storage

### [Function Modifiers](/learn/advanced-functions/function-modifiers)

* Use modifiers to efficiently add functionality to multiple functions

### [Structs](/learn/structs/structs-sbs)

* Construct a `struct` (user-defined type) that contains several different data types
* Declare members of the `struct` to maximize storage efficiency
* Describe constraints related to the assignment of `struct`s depending on the types they contain

### [Inheritance](/learn/inheritance/inheritance-sbs)

* Write a smart contract that inherits from another contract
* Describe the impact inheritance has on the byte code size limit

### [Multiple Inheritance](/learn/inheritance/multiple-inheritance)

* Write a smart contract that inherits from multiple contracts

### [Abstract Contracts](/learn/inheritance/abstract-contracts-sbs)

* Use the virtual, override, and abstract keywords to create and use an abstract contract

### [Imports](/learn/imports/imports-sbs)

* Import and use code from another file
* Utilize OpenZeppelin contracts within Remix

### [Error Triage](/learn/error-triage/error-triage)

* Debug common solidity errors including transaction reverted, out of gas, stack overflow, value overflow/underflow, index out of range, etc.

### [The New Keyword](/learn/new-keyword/new-keyword-sbs)

* Write a contract that creates a new contract with the new keyword

### ['Contract to Contract Interaction'](/learn/interfaces/contract-to-contract-interaction)

* Use interfaces to allow a smart contract to call functions in another smart contract
* Use the `call()` function to interact with another contract without using an interface

### [Events](/learn/events/hardhat-events-sbs)

* Write and trigger an event
* List common uses of events
* Understand events vs. smart contract storage

### [Address and Payable in Solidity](/learn/address-and-payable/address-and-payable)

* Differentiate between address and address payable types in Solidity
* Determine when to use each type appropriately in contract development
* Employ address payable to send Ether and interact with payable functions

### [Minimal Token](/learn/token-development/minimal-tokens/minimal-token-sbs)

* Construct a minimal token and deploy to testnet
* Identify the properties that make a token a token

### [The ERC-20 Token Standard](/learn/token-development/erc-20-token/erc-20-standard)

* Analyze the anatomy of an ERC-20 token
* Review the formal specification for ERC-20

### [ERC-20 Implementation](/learn/token-development/erc-20-token/erc-20-token-sbs)

* Describe OpenZeppelin
* Import the OpenZeppelin ERC-20 implementation
* Describe the difference between the ERC-20 standard and OpenZeppelin's ERC20.sol
* Build and deploy an ERC-20 compliant token

### [The ERC-721 Token Standard](/learn/token-development/erc-721-token/erc-721-standard)

* Analyze the anatomy of an ERC-721 token
* Compare and contrast the technical specifications of ERC-20 and ERC-721
* Review the formal specification for ERC-721

### [ERC-721 Token](/learn/token-development/erc-721-token/erc-721-sbs)

* Analyze the anatomy of an ERC-721 token
* Compare and contrast the technical specifications of ERC-20 and ERC-721
* Review the formal specification for ERC-721
* Build and deploy an ERC-721 compliant token
* Use an ERC-721 token to control ownership of another data structure

### [Wallet Connectors](/learn/onchain-app-development/frontend-setup/wallet-connectors)

* Identify the role of a wallet aggregator in an onchain app
* Debate the pros and cons of using a template
* Scaffold a new onchain app with RainbowKit
* Support users of EOAs and the Coinbase Smart Wallet with the same app

### [Building an Onchain App](/learn/onchain-app-development/frontend-setup/building-an-onchain-app)

* Identify the role of a wallet aggregator in an onchain app
* Debate the pros and cons of using a template
* Add a wallet connection to a standard template app

### [The `useAccount` Hook](/learn/onchain-app-development/reading-and-displaying-data/useAccount)

* Implement the `useAccount` hook to show the user's address, connection state, network, and balance
* Implement an `isMounted` hook to prevent hydration errors

### [The `useReadContract` Hook](/learn/onchain-app-development/reading-and-displaying-data/useReadContract)

* Implement wagmi's `useReadContract` hook to fetch data from a smart contract
* Convert data fetched from a smart contract to information displayed to the user
* Identify the caveats of reading data from automatically-generated getters

### [Configuring `useReadContract`](/learn/onchain-app-development/reading-and-displaying-data/configuring-useReadContract)

* Use `useBlockNumber` and the `queryClient` to automatically fetch updates from the blockchain
* Describe the costs of using the above, and methods to reduce those costs
* Configure arguments to be passed with a call to a `pure` or `view` smart contract function
* Call an instance of `useReadContract` on demand
* Utilize `isLoading` and `isFetching` to improve user experience

### [The `useWriteContract` hook](/learn/onchain-app-development/writing-to-contracts/useWriteContract)

* Implement wagmi's `useWriteContract` hook to send transactions to a smart contract
* Configure the options in `useWriteContract`
* Display the execution, success, or failure of a function with button state changes, and data display

### [The `useSimulateContract` hook](/learn/onchain-app-development/writing-to-contracts/useSimulateContract)

* Implement wagmi's `useSimulateContract` and `useWriteContract` to send transactions to a smart contract
* Configure the options in `useSimulateContract` and `useWriteContract`
* Call a smart contract function on-demand using the write function from `useWriteContract`, with arguments and a value


# Overview

OnchainKit is a full-featured React library for building onchain applications. Whether you're creating a web app, mini app, or hybrid app, OnchainKit provides components and utilities to help you build quickly and easily.

From wallet connection and transactions to identity resolution and DeFi integrations, OnchainKit has you covered.

## An all-in-one web app and mini app solution

OnchainKit helps you build traditional onchain web apps, mini apps, and hybrid apps (apps that work in Farcaster clients such as the Base app, as well as the browser).

If you're new to mini apps, they are supercharged web apps that get additional functionality such as automatic wallet connection, push notifications, and more. Check out the [Mini Apps documentation](/mini-apps/overview) for more information.

## Philosophy

OnchainKit aims to provide a comprehensive toolkit that combines powerful onchain features with developer-friendly design. It's built with the following principles in mind:

* **Ergonomic design:** Full-stack tools that make complex onchain interactions intuitive
* **Battle-tested patterns:** Industry best practices packaged into ready-to-use solutions
* **Purpose-built components:** Pre-built modules for common onchain workflows
* **Framework agnostic:** Compatible with any React framework
* **Supercharged by Base:** Deep integration with Base's protocol features and ecosystem

## Key Features

OnchainKit provides everything you need to build modern onchain applications:

* **Wallet Components** - Connection, selection, and management UI
* **Identity System** - ENS/Basename resolution and profile display
* **Transaction Tools** - Transaction building, sending, and status tracking
* **DeFi Integration** - Token swaps, yield farming, and portfolio management
* **Commerce Components** - Onramp, checkout, and payment flows
* **Advanced Customization** - Render props for complete UI control while maintaining functionality

## Customization

OnchainKit components are designed to be highly customizable. In addition to standard props like `className` and `children`, many components support **render props** for complete control over their UI while maintaining all underlying functionality.

Render props let you implement custom designs for buttons, inputs, and other interactive elements while OnchainKit handles the complex onchain logic:

```tsx  theme={null}
// Example: Custom wallet connect button
<ConnectWallet
  render={({ onClick, status, isLoading }) => (
    <button onClick={onClick} className="my-custom-style">
      {status === 'disconnected' ? 'Connect' : 'Connected'}
    </button>
  )}
/>
```

Components with render prop support include `ConnectWallet`, `TransactionButton`, `SignatureButton`, various `Swap` components, and `Fund` components. Check individual component documentation for specific render prop interfaces.

<Check>
  These docs are LLM-friendly. Reference the [OnchainKit AI Prompting Guide](/onchainkit/guides/ai-prompting-guide) in your code editor to streamline builds and prompt smarter.
</Check>


# Quickstart Guide

Building a new app? The easiest way to get started is to use `npx create-onchain`, which sets up everything automatically for you.

After running `npx create-onchain` and following the prompts, you'll have a [Next.js](https://nextjs.org/) project with OnchainKit installed and ready to go.

## Bootstrapping a new project

### Mini app support

If you're building a mini app or hybrid app, you can use the `--mini` flag to bootstrap a project with mini app support.

```bash Terminal theme={null}
npx create-onchain --mini
```

### Traditional onchain web app

If you don't want to use mini app features, simply omit the `--mini` flag. If you decide to add mini app features later, you can convert your project to a mini by making some small changes to your codebase.

```bash Terminal theme={null}
npx create-onchain
```

## CLI settings

The CLI will ask you a few simple questions to help you get started.

These are:

* Your project's name
* Your [Coinbase Developer Platform Client API key](https://portal.cdp.coinbase.com/products/onchainkit) (optional)
* Whether you'd like to enable telemetry (optional)

After this, simply `cd` into your project folder and run `npm install` (or use your package manager of choice) to install the dependencies.

Finally, run `npm run dev` to start the project and get to building!

## What you get

The generated project includes:

* **Next.js scaffold** - A new Next.js 15 project using the App Router
* **OnchainKit components** - Pre-configured OnchainKit provider and components
* **Wagmi & Viem integration** - Ready to use and set up for the Base network
* **TypeScript** - Full type safety out of the box

## Need more control?

For existing projects or custom setups, check out the [Manual Installation Guide](./manual-installation) for step-by-step integration instructions.


# Manual Installation

Working in an existing React project? Here's how to manually install and configure OnchainKit.

## Install the required dependencies

Add OnchainKit and its peer dependencies to your project:

```bash Terminal theme={null}
npm install @coinbase/onchainkit react react-dom wagmi viem
```

Or with your preferred package manager:

```bash Terminal theme={null}
# pnpm
pnpm add @coinbase/onchainkit react react-dom wagmi viem

# yarn
yarn add @coinbase/onchainkit react react-dom wagmi viem
```

## Import styles

OnchainKit components need the base styles to look correct. Import them in your app's root layout or main CSS file:

```tsx app/layout.tsx theme={null}
import '@coinbase/onchainkit/styles.css';
```

Or in your main CSS file:

```css globals.css theme={null}
@import '@coinbase/onchainkit/styles.css';
```

## Set up and configure the provider

Wrap your app with the `OnchainKitProvider`. This gives all OnchainKit components access to your chain configuration and API keys.

OnchainKit handles Wagmi and React Query setup internally, so you just need to configure the provider with your preferences.

If you want to customize these providers, check out the [Custom Providers](/advanced/custom-providers) page.

```tsx app/layout.tsx theme={null}
'use client';
import { OnchainKitProvider } from '@coinbase/onchainkit';
import { base } from 'wagmi/chains';

export default function RootLayout({ children }) {
  return (
    <OnchainKitProvider
      apiKey="YOUR_API_KEY"
      chain={base}
      config={{
        appearance: {
          mode: 'auto', // 'light' | 'dark' | 'auto'
        },
        wallet: {
          display: 'modal', // 'modal' | 'drawer'
          preference: 'all', // 'all' | 'smartWalletOnly' | 'eoaOnly'
        },
      }}
    >
      <html>
        <body>
          {children}
        </body>
      </html>
    </OnchainKitProvider>
  );
}
```

## Environment variables (optional)

While you can hardcode your API key directly in the provider, it may be cleaner to use environment variables for security, especially in production apps.

### Next.js

Create a `.env.local` file in your project root:

```bash .env.local theme={null}
NEXT_PUBLIC_ONCHAINKIT_API_KEY=your_api_key_here
```

### Vite

Create a `.env` file in your project root:

```bash .env theme={null}
VITE_ONCHAINKIT_API_KEY=your_api_key_here
```

### Other frameworks

Follow your framework's convention for environment variables. Most React frameworks support `.env` files.

### Using the environment variable

```tsx  theme={null}
<OnchainKitProvider
  apiKey={
    // Next.js
    process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY ||
    // Vite
    import.meta.env.VITE_ONCHAINKIT_API_KEY ||
    // Hardcoded fallback
    "your_api_key_here"
  }
  chain={base}
>
```

## Basic usage

Now you can start using OnchainKit components:

```tsx components/WalletDemo.tsx theme={null}
'use client';
import {
  ConnectWallet,
  Wallet,
  WalletDropdown,
  WalletDropdownDisconnect,
} from '@coinbase/onchainkit/wallet';

export default function WalletDemo() {
  return (
    <Wallet>
      <ConnectWallet />
      <WalletDropdown />
    </Wallet>
  );
}
```

## Mini app setup

If you're building a mini app, you'll need to follow a couple additional steps:

### 1. Enable MiniKit in the provider

```tsx app/layout.tsx theme={null}
<OnchainKitProvider
  apiKey="YOUR_API_KEY"
  chain={base}
  miniKit={{
    enabled: true, // Add this
  }}
>
```

### 2. Add SafeArea component

Wrap your main content to handle safe areas on mobile.

If you want to wrap your whole application, put this in your root layout.

```tsx app/page.tsx theme={null}
import { SafeArea } from '@coinbase/onchainkit/minikit';

export default function Home() {
  return (
    <SafeArea>
      <main>
        {/* Your app content */}
      </main>
    </SafeArea>
  );
}
```

### 3. Create the manifest endpoint

Create an API route that serves your Farcaster manifest.

See the [manifest documentation](/mini-apps/features/manifest) for more information.

```tsx app/api/.well-known/farcaster.json/route.ts theme={null}
export async function GET() {
  return Response.json({
    // ...your manifest data...
  });
}
```

## Next steps

* Check out the [component documentation](/onchainkit/latest/components) to see what's available
* Read the [configuration guide](/onchainkit/latest/configuration) for advanced setup options


# Troubleshooting

Running into issues? This guide covers the most common problems and how to fix them. Can't find your issue? Check our [GitHub Issues](https://github.com/coinbase/onchainkit/issues) or ask in [Discord](https://discord.gg/invite/buildonbase).

## Common Issues

### Environment Setup

* **Missing Project ID**

  * Error: "Project ID is required for this component"
  * Solution: Add your Project ID to the OnchainKitProvider:

```tsx  theme={null}
<OnchainKitProvider
  apiKey="YOUR_API_KEY"
  projectId="YOUR_PROJECT_ID" // Get this from portal.cdp.coinbase.com
  chain={base}
>
```

* **Contracts Not Available**
  * Error: "Contracts are not available" or "Contracts not available for LifecycleStatus"
  * Solutions:
    * Double-check your OnchainKit API key is set correctly
    * Make sure you're using an API key from [portal.cdp.coinbase.com](https://portal.cdp.coinbase.com)
    * Verify your environment variables are properly exposed to the client

### Dependencies

* **Version Compatibility**
  * Issue: Compilation failures or TypeScript errors
  * Solution: Make sure you're using compatible package versions:

```json  theme={null}
{
  "dependencies": {
    "@coinbase/onchainkit": "^1.0.0",
    "react": "^19",
    "react-dom": "^19",
    "viem": "^2.27.0",
    "wagmi": "^2.16.0"
  }
}
```

### Provider Configuration

* **Missing OnchainKitProvider**

  * Issue: Missing OnchainKitProvider context values
  * Solution: Wrap your app with OnchainKitProvider. See our [setup guide](/getting-started/manual-installation) for details:

```tsx  theme={null}
import { OnchainKitProvider } from '@coinbase/onchainkit';
import { base } from 'viem/chains';

export default function App({ children }) {
  return (
    <OnchainKitProvider
      apiKey={process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY}
      chain={base}
    >
      {children}
    </OnchainKitProvider>
  );
}
```

### Wallet Connection

* **Connection Failed**

  * Error: "Unable to connect wallet"
  * Solutions:
    * Make sure your wallet extension is installed and unlocked
    * Check that you're on a supported network
    * Try switching networks in your wallet
    * Verify your RPC endpoints are working

* **Chain Switching Issues**
  * Error: "Failed to switch chain"
  * Solutions:
    * Make sure the chain is supported by OnchainKit
    * Check that your wallet has the right permissions
    * Verify your RPC endpoints are set up correctly
    * Try manually adding the chain to your wallet first

### Transaction Issues

* **Gas Estimation Failed**
  * Error: "Gas estimation failed"
  * Solutions:
    * Make sure you have enough ETH for gas fees
    * Double-check your transaction parameters
    * Verify you're on the right network

### Module Resolution

* **Module Resolution Errors**
  * Error: "Cannot find module ... or its corresponding type declarations"
  * Solution: OnchainKit only supports ES Modules, not CommonJS. Use Node 22+ and set `"moduleResolution": "NodeNext"` in your TypeScript config for the best experience.

## Getting Help

Need more help?

* [Discord Community](https://discord.gg/invite/buildonbase)
* [GitHub Issues](https://github.com/coinbase/onchainkit/issues)


# OnchainKitProvider

The OnchainKitProvider provides the React context that powers all OnchainKit components. It handles wallet connections, theming, API configuration, and MiniKit integration.

## Basic Usage

To get started, wrap your app with `OnchainKitProvider` and provide the required props described below.

Also, import `'@coinbase/onchainkit/styles.css'` to ensure OnchainKit's components are styled correctly.

In the example below, we're creating a `RootProvider` to keep our code organized.

```tsx RootProvider.tsx theme={null}
'use client';
import { ReactNode } from 'react';
import { base } from 'viem/chains';
import { OnchainKitProvider } from '@coinbase/onchainkit';
import '@coinbase/onchainkit/styles.css';

export function RootProvider({ children }: { children: ReactNode }) {
  return (
    <OnchainKitProvider
      apiKey={process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY}
      chain={base}
      config={{
        appearance: {
          mode: 'auto',
        },
        wallet: {
          display: 'modal',
        },
      }}
    >
      {children}
    </OnchainKitProvider>
  );
}
```

Then, we're wrapping our app with the `RootProvider` in our root layout.

```tsx layout.tsx theme={null}
import { RootProvider } from './RootProvider';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <RootProvider>{children}</RootProvider>
      </body>
    </html>
  );
}
```

## Props

| Prop                       | Description                                                            | Required |
| -------------------------- | ---------------------------------------------------------------------- | -------- |
| [`chain`](#chain)          | The blockchain network your app operates on.                           | Yes      |
| [`apiKey`](#apikey)        | Coinbase Developer Platform API key for accessing OnchainKit services. | No       |
| [`projectId`](#project-id) | Coinbase Developer Platform Project ID for funding components.         | No       |
| [`rpcUrl`](#rpc-url)       | Custom RPC endpoint for blockchain requests.                           | No       |
| [`config`](#config)        | Configuration object for appearance, wallet settings, and paymaster.   | No       |
| [`miniKit`](#minikit)      | MiniKit configuration for mini app features.                           | No       |
| [`analytics`](#analytics)  | Enable/disable usage analytics (defaults to true).                     | No       |
| `defaultPublicClients`     | Custom viem public clients for specific chains.                        | No       |

### Chain

Specifies the blockchain network your OnchainKit components will use. This is required for all OnchainKit functionality.

```tsx  theme={null}
import { base, mainnet } from 'viem/chains';

// Use Base network
<OnchainKitProvider chain={base}>
  {children}
</OnchainKitProvider>

// Use Ethereum mainnet
<OnchainKitProvider chain={mainnet}>
  {children}
</OnchainKitProvider>
```

Import chain configurations from [viem/chains](https://viem.sh/docs/chains/introduction) for type safety and accuracy.

### API Key

Your Coinbase Developer Platform API key enables access to OnchainKit services like token data, swap quotes, and transaction sponsorship.

Required for:

* Swap components and APIs
* Transaction components with sponsorship
* Token data and metadata
* NFT minting components

Get your API key from the [Coinbase Developer Platform](https://portal.cdp.coinbase.com/products/onchainkit).

```tsx  theme={null}
<OnchainKitProvider
  apiKey={process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY}
  chain={base}
>
  {children}
</OnchainKitProvider>
```

<Frame>
  <img alt="OnchainKit copy Client API Key" src="https://mintlify.s3.us-west-1.amazonaws.com/base-a060aa97/onchainkit/latest/configuration/images/copy-api-key-guide.png" height="364" />
</Frame>

### RPC URL

Custom RPC endpoint for blockchain requests. If not provided, OnchainKit uses the Coinbase Developer Platform Node (requires `apiKey`).

```tsx  theme={null}
<OnchainKitProvider
  chain={base}
  rpcUrl="https://your-custom-rpc-endpoint.com"
>
  {children}
</OnchainKitProvider>
```

Most applications can omit this and use the default CDP Node by providing an `apiKey`.

### Project ID

Your Coinbase Developer Platform Project ID, required for funding and onramp components.

```tsx  theme={null}
<OnchainKitProvider
  chain={base}
  projectId={process.env.NEXT_PUBLIC_CDP_PROJECT_ID}
>
  {children}
</OnchainKitProvider>
```

Get your Project ID from the [Coinbase Developer Platform](https://portal.cdp.coinbase.com/projects).

<Frame>
  <img alt="OnchainKit copy Project ID" src="https://mintlify.s3.us-west-1.amazonaws.com/base-a060aa97/onchainkit/latest/configuration/images/copy-project-id.png" height="364" />
</Frame>

### Config

Configuration object to customize OnchainKit's appearance, wallet behavior, and gas sponsorship.

```tsx  theme={null}
<OnchainKitProvider
  chain={base}
  config={{
    appearance: {
      name: 'My App',
      logo: 'https://example.com/logo.png',
      mode: 'auto',
      theme: 'default',
    },
    wallet: {
      display: 'modal',
      preference: 'all',
      termsUrl: 'https://example.com/terms',
      privacyUrl: 'https://example.com/privacy',
      supportedWallets: {
        rabby: true,
        trust: true,
      },
    },
    paymaster: 'https://api.developer.coinbase.com/rpc/v1/base/your-api-key',
    analytics: true,
  }}
>
  {children}
</OnchainKitProvider>
```

#### Appearance

Controls visual styling and branding:

* `name` — Your app's name displayed in components
* `logo` — URL to your app's logo
* `mode` — Color scheme: `'auto'`, `'light'`, or `'dark'`
* `theme` — Visual theme: `'default'`, `'base'`, `'cyberpunk'`, `'hacker'`, or custom

#### Wallet

Wallet connection and display settings:

* `display` — Interface style: `'modal'` (overlay) or `'classic'` (inline)
* `preference` — Coinbase Wallet preference: `'all'`, `'smartWalletOnly'`, or `'eoaOnly'`
* `termsUrl` — Link to your terms of service
* `privacyUrl` — Link to your privacy policy
* `supportedWallets` — Enable additional wallets: `rabby`, `trust`, `frame`

#### Paymaster

URL for gas sponsorship. Configure through [Coinbase Developer Platform](https://portal.cdp.coinbase.com/products/bundler-and-paymaster).

#### Analytics

Enable/disable usage analytics (defaults to `true`).

### MiniKit

Configuration for mini app features. Only needed when building mini apps.

```tsx  theme={null}
<OnchainKitProvider
  chain={base}
  miniKit={{
    enabled: true,
    autoConnect: true,
    notificationProxyUrl: '/api/notify',
  }}
>
  {children}
</OnchainKitProvider>
```

Options:

* `enabled` — Enable MiniKit features (defaults to `false`)
* `autoConnect` — Auto-connect when in mini apps (defaults to `true`)
* `notificationProxyUrl` — Custom notification proxy URL (defaults to `/api/notify`)

### Analytics

Enable or disable OnchainKit usage analytics.

```tsx  theme={null}
<OnchainKitProvider
  chain={base}
  analytics={false} // Disable analytics
>
  {children}
</OnchainKitProvider>
```

Defaults to `true`. Analytics help improve OnchainKit but can be disabled for privacy.

### Default Public Clients

Custom viem public clients for specific chains. Useful when you need custom RPC configurations or want to use your own client settings.

```tsx  theme={null}
import { createPublicClient, http } from 'viem';
import { base, mainnet } from 'viem/chains';

const customClients = {
  [base.id]: createPublicClient({
    chain: base,
    transport: http('https://your-custom-base-rpc.com'),
  }),
  [mainnet.id]: createPublicClient({
    chain: mainnet,
    transport: http('https://your-custom-mainnet-rpc.com'),
    batch: {
      multicall: true,
    },
  }),
};

<OnchainKitProvider
  chain={base}
  defaultPublicClients={customClients}
>
  {children}
</OnchainKitProvider>
```

Use cases:

* Custom RPC endpoints with specific configurations
* Enhanced client settings (batching, caching, retries)
* Private or premium RPC providers
* Multi-chain applications with different client requirements per chain


# Wagmi & Viem Integration

OnchainKit automatically sets up Wagmi and TanStack Query providers for you. However, you can provide your own custom Wagmi configuration for advanced use cases like custom connectors, chains, or storage options.

## Default Setup

By default, OnchainKitProvider handles all the provider setup internally:

```tsx  theme={null}
<OnchainKitProvider
  apiKey={process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY}
  chain={base}
>
  {children}
</OnchainKitProvider>
```

This automatically includes:

* Wagmi configuration with Coinbase Wallet connector
* TanStack Query client for caching
* Optimized defaults for most applications

## Custom Wagmi Configuration

For advanced control over wallet connectors, chains, or other Wagmi settings, wrap OnchainKitProvider with your own Wagmi providers:

<CodeGroup>
  ```tsx wagmi.ts theme={null}
  import { http, cookieStorage, createConfig, createStorage } from 'wagmi';
  import { base, baseSepolia } from 'viem/chains';
  import { coinbaseWallet, metaMask } from 'wagmi/connectors';

  export function getConfig() {
    return createConfig({
      chains: [base, baseSepolia],
      connectors: [
        coinbaseWallet({
          appName: 'My OnchainKit App',
          preference: 'smartWalletOnly',
          version: '4',
        }),
        metaMask(), // Add additional connectors
      ],
      storage: createStorage({
        storage: cookieStorage,
      }),
      ssr: true,
      transports: {
        [base.id]: http(),
        [baseSepolia.id]: http(),
      },
    });
  }

  declare module 'wagmi' {
    interface Register {
      config: ReturnType<typeof getConfig>;
    }
  }
  ```

  ```tsx providers.tsx theme={null}
  import { OnchainKitProvider } from '@coinbase/onchainkit';
  import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
  import { base } from 'viem/chains';
  import { type ReactNode, useState } from 'react';
  import { type State, WagmiProvider } from 'wagmi';
  import { getConfig } from './wagmi';

  export function Providers(props: {
    children: ReactNode;
    initialState?: State;
  }) {
    const [config] = useState(() => getConfig());
    const [queryClient] = useState(() => new QueryClient());

    return (
      <WagmiProvider config={config} initialState={props.initialState}>
        <QueryClientProvider client={queryClient}>
          <OnchainKitProvider
            apiKey={process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY}
            chain={base}
          >
            {props.children}
          </OnchainKitProvider>
        </QueryClientProvider>
      </WagmiProvider>
    );
  }
  ```
</CodeGroup>

## When to Use Custom Configuration

Consider custom Wagmi configuration when you need:

* **Multiple chains** beyond the primary chain
* **Advanced caching** with custom QueryClient settings
* **SSR support** with cookie-based persistence
* **Custom transports** or RPC configurations

## Common Patterns

### Multi-chain Support

```tsx wagmi.ts theme={null}
import { base, mainnet, optimism } from 'viem/chains';

export function getConfig() {
  return createConfig({
    chains: [base, mainnet, optimism],
    // ... other config
    transports: {
      [base.id]: http(),
      [mainnet.id]: http(),
      [optimism.id]: http(),
    },
  });
}
```

### Custom Query Client

```tsx providers.tsx theme={null}
const [queryClient] = useState(() => new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,
    },
  },
}));
```

### Environment-specific Configuration

```tsx wagmi.ts theme={null}
const isDevelopment = process.env.NODE_ENV === 'development';

export function getConfig() {
  return createConfig({
    chains: isDevelopment ? [baseSepolia] : [base],
    // ... development vs production settings
  });
}
```

## Important Notes

* Always place custom Wagmi and Query providers **outside** of OnchainKitProvider
* OnchainKit components will use your custom Wagmi configuration automatically
* The `chain` prop on OnchainKitProvider should match your primary chain
* Custom configurations require additional setup but provide maximum flexibility


# Themes

> Customize the appearance of OnchainKit components with built-in themes or create your own

<Frame>
  <img alt="Themes" src="https://mintcdn.com/base-a060aa97/-q4fo0uzIfxlH3Wn/images/onchainkit/onchainkit-themes.gif?s=d23e9bf5e14518c089c3ff4bd81a91f6" height="364" data-og-width="1744" data-og-height="1080" data-path="images/onchainkit/onchainkit-themes.gif" data-optimize="true" data-opv="3" />
</Frame>

## Overview

OnchainKit provides flexible appearance control through two main features: `mode` and `theme`.

* **Mode**: Controls the light/dark appearance with `auto`, `light`, or `dark` options
* **Theme**: Sets the overall styling including colors, fonts, and border radius

Configure themes through the `OnchainKitProvider` to create a customized interface that matches your application's design.

## Built-in Themes

OnchainKit includes several built-in themes. Set the theme via the `OnchainKitProvider` using `config.appearance.theme`:

* `default`: Multi-mode theme with light and dark variants
* `base`: Base brand colors, available in light and dark modes
* `cyberpunk`: Dark-only theme with fuchsia accents and Oxanium font
* `hacker`: Monospace theme with zinc colors and Noto Sans Mono font

If no theme is specified, the `default` theme is used.

```tsx  theme={null}
<OnchainKitProvider
  apiKey={process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY}
  chain={base}
  config={{ // [!code focus]
    appearance: { // [!code focus]
      mode: 'auto', // 'auto' | 'light' | 'dark'
      theme: 'default', // 'default' | 'base' | 'cyberpunk' | 'hacker' // [!code focus]
    }, // [!code focus]
  }} // [!code focus]
>
```

## Mode

Control the color scheme by setting the `config.appearance.mode` property:

* `auto`: Automatically switches between light and dark based on system preference (default)
* `light`: Forces light mode for all components
* `dark`: Forces dark mode for all components

Note: Single-mode themes like `cyberpunk` and `hacker` ignore the mode setting.

```tsx  theme={null}
<OnchainKitProvider
  apiKey={process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY}
  chain={base}
  config={{
    appearance: {
      mode: 'auto', // 'auto' | 'light' | 'dark' // [!code focus]
      theme: 'default', // 'default' | 'base' | 'cyberpunk' | 'hacker'
    },
  }}
>
```

## CSS Overrides

Fine-tune specific aspects of an existing theme by overriding CSS variables.

```css  theme={null}
@layer base {
  [data-ock-theme='default-light'],
  [data-ock-theme='default-dark'],
  [data-ock-theme='base-light'],
  [data-ock-theme='base-dark'],
  [data-ock-theme='cyberpunk'],
  [data-ock-theme='hacker'] {
    /* Override specific variables */
    --ock-font-family: 'Roboto', sans-serif;
    --ock-radius-default: 0.5rem;
    --ock-primary: #ff6b35;
  }
}
```

## Custom Theme

Create a completely custom theme with full control over colors, fonts, and styling.

### Custom Theme Setup

Define your custom theme using CSS variables. Theme classes should include `-light` and `-dark` suffixes for multi-mode support:

```tsx  theme={null}
<OnchainKitProvider
  apiKey={process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY}
  chain={base}
  config={{
    appearance: {
      mode: 'auto', // Will switch between custom-light and custom-dark
      theme: 'custom', // [!code focus]
    },
  }}
>
```

### Theme Definition

Use the correct CSS variable names that match OnchainKit's theming system:

```css  theme={null}
@layer base {
  [data-ock-theme='custom-light'] {
    /* Typography and Shape */
    --ock-font-family: 'Inter', sans-serif;
    --ock-radius-default: 0.75rem;
    --ock-radius-inner: 0.375rem;

    /* Foreground Colors */
    --ock-foreground: #1a1a1a;
    --ock-foreground-muted: #6b7280;
    --ock-foreground-inverse: #ffffff;
    --ock-foreground-disabled: #9ca3af;

    /* Background Colors */
    --ock-background: #ffffff;
    --ock-background-hover: #f3f4f6;
    --ock-background-active: #e5e7eb;
    --ock-background-alternate: #f9fafb;
    --ock-background-alternate-hover: #f3f4f6;
    --ock-background-alternate-active: #e5e7eb;
    --ock-background-inverse: #f3f4f6;
    --ock-background-inverse-hover: #e5e7eb;
    --ock-background-inverse-active: #d1d5db;
    --ock-background-reverse: #1a1a1a;

    /* Primary Colors */
    --ock-primary: #3b82f6;
    --ock-primary-hover: #2563eb;
    --ock-primary-active: #1d4ed8;
    --ock-primary-washed: #dbeafe;
    --ock-primary-disabled: #93c5fd;

    /* Secondary Colors */
    --ock-secondary: #e2e8f0;
    --ock-secondary-hover: #cbd5e1;
    --ock-secondary-active: #94a3b8;

    /* State Colors */
    --ock-error: #dc2626;
    --ock-warning: #d97706;
    --ock-success: #16a34a;
    --ock-success-background: #bbf7d0;

    /* Lines */
    --ock-line: #e5e7eb;
  }

  [data-ock-theme='custom-dark'] {
    /* Define dark mode variables here */
    --ock-foreground: #ffffff;
    --ock-foreground-muted: #9ca3af;
    --ock-background: #1a1a1a;
    /* ... other dark mode variables */
  }
}
```
# Connected

The `Connected` component provides conditional rendering based on wallet connection state. It renders children when a wallet is connected, and shows a fallback UI when no wallet is connected.

This component simplifies building wallet-aware user interfaces by handling the common pattern of showing different content for connected vs. disconnected states.

## Usage

### Basic usage

The simplest usage shows children when connected and a `ConnectWallet` button when disconnected:

```tsx  theme={null}
import { Connected } from '@coinbase/onchainkit/connected';

export default function MyComponent() {
  return (
    <Connected>
      <div>Welcome! Your wallet is connected.</div>
    </Connected>
  );
}
```

When no wallet is connected, this automatically renders a `ConnectWallet` button.

### Custom fallback

Provide a custom fallback UI for when no wallet is connected:

```tsx  theme={null}
import { Connected } from '@coinbase/onchainkit/connected';

export default function MyComponent() {
  return (
    <Connected
      fallback={
        <div className="text-center p-4">
          <h2>Connect your wallet</h2>
          <p>Please connect your wallet to continue</p>
        </div>
      }
    >
      <div>Welcome! Your wallet is connected.</div>
    </Connected>
  );
}
```

### No fallback

Pass `null` as the fallback to render nothing when disconnected:

```tsx  theme={null}
import { Connected } from '@coinbase/onchainkit/connected';

export default function MyComponent() {
  return (
    <Connected fallback={null}>
      <div>This only shows when connected</div>
    </Connected>
  );
}
```

### Connecting state

Show a loading state while the wallet is connecting:

```tsx  theme={null}
import { Connected } from '@coinbase/onchainkit/connected';

export default function MyComponent() {
  return (
    <Connected
      connecting={
        <div className="flex items-center gap-2">
          <div className="animate-spin w-4 h-4 border-2 border-blue-500 rounded-full border-t-transparent" />
          <span>Connecting wallet...</span>
        </div>
      }
      fallback={
        <button className="bg-blue-500 text-white px-4 py-2 rounded">
          Connect Wallet
        </button>
      }
    >
      <div>Wallet connected successfully!</div>
    </Connected>
  );
}
```

## Advanced Usage

### Building complex flows

Use `Connected` to create sophisticated user flows that adapt to connection state:

```tsx  theme={null}
import { Connected } from '@coinbase/onchainkit/connected';
import { Transaction, TransactionButton } from '@coinbase/onchainkit/transaction';

export default function MintFlow() {
  return (
    <div className="space-y-4">
      <h1>Mint Your NFT</h1>

      <Connected
        connecting={<div>Preparing wallet...</div>}
        fallback={
          <div className="border rounded-lg p-6 text-center">
            <h2>Connect to get started</h2>
            <p className="text-gray-600 mb-4">
              You need to connect your wallet to mint an NFT
            </p>
          </div>
        }
      >
        <div className="border rounded-lg p-6">
          <h2>Ready to mint!</h2>
          <p className="text-gray-600 mb-4">
            Your wallet is connected. Click below to mint your NFT.
          </p>

          <Transaction
            calls={[
              {
                to: '0x...',
                data: '0x...',
              },
            ]}
          >
            <TransactionButton>Mint NFT</TransactionButton>
          </Transaction>
        </div>
      </Connected>
    </div>
  );
}
```

### Conditional navigation

Hide navigation items when wallet is not connected:

```tsx  theme={null}
import { Connected } from '@coinbase/onchainkit/connected';

export default function Navigation() {
  return (
    <nav className="flex items-center justify-between p-4">
      <div>My App</div>

      <div className="flex items-center gap-4">
        <Connected fallback={null}>
          <a href="/dashboard">Dashboard</a>
          <a href="/profile">Profile</a>
        </Connected>

        <Connected>
          <span>Wallet connected</span>
        </Connected>
      </div>
    </nav>
  );
}
```

## Props

```ts  theme={null}
type ConnectedProps<TFallback extends ReactNode | undefined = undefined> =
  TFallback extends undefined
    ? ConnectedBaseProps<TFallback> & ConnectWalletFallbackProps
    : ConnectedBaseProps<TFallback>;

type ConnectedBaseProps<TFallback extends ReactNode | undefined> = {
  /**
   * The content to render when there is a connected account.
   */
  children: ReactNode;
  /**
   * The content to render when there is no connected account.
   * If undefined, defaults to rendering the `<ConnectWallet />` button.
   * Pass `null` to render nothing.
   */
  fallback?: TFallback;
  /**
   * If defined, the content to render when there is no connected account
   * and `useAccount().status` is "connecting".
   */
  connecting?: ReactNode;
};
```

When no `fallback` prop is provided, the component accepts all props that `ConnectWallet` accepts as passthrough props.


# Overview

> The best way to build Mini Apps on Base.

MiniKit is the official SDK for building Mini Apps that work seamlessly across Base App and other Farcaster clients. It provides React hooks, context management, and wallet integration that eliminates the complexity of building social-native applications.

## Why MiniKit?

<CardGroup cols={2}>
  <Card title="Seamless Integration" icon="link">
    Part of OnchainKit allowing for complete onchain app development with shared providers and configuration.
  </Card>

  <Card title="Social-Native" icon="users">
    Built specifically for Farcaster's frame-based architecture with native social features.
  </Card>

  <Card title="Wallet Abstraction" icon="wallet">
    Simplified wallet connections and transaction flows with automatic provider detection.
  </Card>

  <Card title="Cross-Client" icon="mobile">
    Works across Base App, Farcaster, and other clients with consistent behavior.
  </Card>
</CardGroup>

## Architecture

MiniKit consists of three main components:

### `<OnchainKitProvider miniKit={{ enabled: true }}>`

React context provider that configures:

* Wagmi and react-query setup
* Chain and API key configuration
* Theme and appearance settings
* Farcaster connector integration

### Hooks

React hooks for frame interactions:

* **Frame Management**: `useMiniKit`, `useAddFrame`, `useClose`
* **Navigation**: `useOpenUrl`, `useViewProfile`, `useViewCast`
* **Social**: `useComposeCast`, `useNotification`
* **Authentication**: `useAuthenticate`
* **UI**: `usePrimaryButton`

### CLI Tools

Command-line utilities for:

* Project scaffolding with `npx create-onchain --mini`
* Manifest generation with `npx create-onchain --manifest`
* Development workflow automation

## Getting Started

<CardGroup cols={2}>
  <Card title="New Project" icon="plus" href="/mini-apps/quickstart/new-apps/install">
    Create a new Mini App from scratch using the CLI scaffolding tool.
  </Card>

  <Card title="Existing App" icon="code" href="/mini-apps/quickstart/existing-apps/install">
    Add MiniKit to your existing Next.js application.
  </Card>
</CardGroup>

## Key Concepts

### Frame Lifecycle

Mini Apps run within Farcaster frames and must signal readiness:

1. **Initialize** MiniKitProvider in your app root
2. **Signal readiness** with `setFrameReady()` in your main component
3. **Handle interactions** through MiniKit hooks

### Context vs Authentication

* **Context data** (`useMiniKit().context`) provides user info but can be spoofed
* **Authentication** (`useAuthenticate()`) provides cryptographically verified user identity
* Always use authentication for security-critical operations

### Cross-Client Compatibility

MiniKit automatically detects the client environment and adapts:

* **Base App**: Native wallet integration, enhanced features
* **Farcaster**: Standard Farcaster protocol compliance
* **Other clients**: Graceful fallbacks and compatibility modes

## Technical Reference

<CardGroup cols={2}>
  <Card title="Provider & Initialization" icon="settings" href="/onchainkit/latest/components/minikit/provider-and-initialization">
    Configure MiniKitProvider and initialize frame context.
  </Card>

  <Card title="Hooks Reference" icon="code" href="/onchainkit/latest/components/minikit/hooks/useMiniKit">
    Complete reference for all MiniKit React hooks.
  </Card>
</CardGroup>


# Overview

> The best way to build Mini Apps on Base.

MiniKit is the official SDK for building Mini Apps that work seamlessly across Base App and other Farcaster clients. It provides React hooks, context management, and wallet integration that eliminates the complexity of building social-native applications.

## Why MiniKit?

<CardGroup cols={2}>
  <Card title="Seamless Integration" icon="link">
    Part of OnchainKit allowing for complete onchain app development with shared providers and configuration.
  </Card>

  <Card title="Social-Native" icon="users">
    Built specifically for Farcaster's frame-based architecture with native social features.
  </Card>

  <Card title="Wallet Abstraction" icon="wallet">
    Simplified wallet connections and transaction flows with automatic provider detection.
  </Card>

  <Card title="Cross-Client" icon="mobile">
    Works across Base App, Farcaster, and other clients with consistent behavior.
  </Card>
</CardGroup>

## Architecture

MiniKit consists of three main components:

### `<OnchainKitProvider miniKit={{ enabled: true }}>`

React context provider that configures:

* Wagmi and react-query setup
* Chain and API key configuration
* Theme and appearance settings
* Farcaster connector integration

### Hooks

React hooks for frame interactions:

* **Frame Management**: `useMiniKit`, `useAddFrame`, `useClose`
* **Navigation**: `useOpenUrl`, `useViewProfile`, `useViewCast`
* **Social**: `useComposeCast`, `useNotification`
* **Authentication**: `useAuthenticate`
* **UI**: `usePrimaryButton`

### CLI Tools

Command-line utilities for:

* Project scaffolding with `npx create-onchain --mini`
* Manifest generation with `npx create-onchain --manifest`
* Development workflow automation

## Getting Started

<CardGroup cols={2}>
  <Card title="New Project" icon="plus" href="/mini-apps/quickstart/new-apps/install">
    Create a new Mini App from scratch using the CLI scaffolding tool.
  </Card>

  <Card title="Existing App" icon="code" href="/mini-apps/quickstart/existing-apps/install">
    Add MiniKit to your existing Next.js application.
  </Card>
</CardGroup>

## Key Concepts

### Frame Lifecycle

Mini Apps run within Farcaster frames and must signal readiness:

1. **Initialize** MiniKitProvider in your app root
2. **Signal readiness** with `setFrameReady()` in your main component
3. **Handle interactions** through MiniKit hooks

### Context vs Authentication

* **Context data** (`useMiniKit().context`) provides user info but can be spoofed
* **Authentication** (`useAuthenticate()`) provides cryptographically verified user identity
* Always use authentication for security-critical operations

### Cross-Client Compatibility

MiniKit automatically detects the client environment and adapts:

* **Base App**: Native wallet integration, enhanced features
* **Farcaster**: Standard Farcaster protocol compliance
* **Other clients**: Graceful fallbacks and compatibility modes

## Technical Reference

<CardGroup cols={2}>
  <Card title="Provider & Initialization" icon="settings" href="/onchainkit/latest/components/minikit/provider-and-initialization">
    Configure MiniKitProvider and initialize frame context.
  </Card>

  <Card title="Hooks Reference" icon="code" href="/onchainkit/latest/components/minikit/hooks/useMiniKit">
    Complete reference for all MiniKit React hooks.
  </Card>
</CardGroup>



# AI Prompting Guide

> Practical techniques for getting better results from AI coding assistants when building with OnchainKit.

Get better results from AI coding assistants when building with OnchainKit. Whether you're using Cursor, GitHub Copilot, or other AI tools, these techniques will improve your workflow.

## Understanding Context Windows

### Why Context Matters

AI coding assistants have a "context window" - the amount of text they can process at once. Think of it as working memory:

* Most assistants process thousands of tokens (roughly 4-5 words per token)
* Everything you share consumes this limited space
* Once full, older conversation parts may be lost

Provide relevant context upfront since AI can only work with what's in its current window.

### Optimizing for Context Windows

Optimize for context windows:

1. **Share relevant info first** - Most important details upfront
2. **Skip unnecessary content** - Avoid irrelevant code or docs
3. **Structure requests clearly** - Use sections and formatting
4. **Reference smartly** - Share only relevant files for large codebases

For larger projects, create a central documentation file rather than repeatedly explaining context.

## Setting Up AI Tools

### Cursor Rules

Cursor Rules provide consistent context to help AI understand your codebase better.

1. Open Command Palette: `Cmd + Shift + P` (Mac) or `Ctrl + Shift + P` (Windows/Linux)
2. Search "Cursor Rules" and create/edit rules
3. Add project-specific rules:
   * [Next.js](https://raw.githubusercontent.com/PatrickJS/awesome-cursorrules/refs/heads/main/rules/nextjs-tailwind-typescript-apps-cursorrules-prompt/.cursorrules)
   * [Astro](https://raw.githubusercontent.com/PatrickJS/awesome-cursorrules/refs/heads/main/rules/astro-typescript-cursorrules-prompt-file/.cursorrules)
   * [Vite](https://raw.githubusercontent.com/PatrickJS/awesome-cursorrules/refs/heads/main/rules/typescript-vite-tailwind-cursorrules-prompt-file/.cursorrules)
4. Save to apply rules to AI suggestions

### OnchainKit Projects

Create a new OnchainKit project:

```shell  theme={null}
npm create onchain@latest
```

After setup, generate comprehensive documentation for your project.

### Creating Project Documentation

A project instructions file helps AI understand your codebase. Create this early and update regularly.

**Instructions.md prompt:**

```
Create a detailed instructions.md file for my OnchainKit project:

1. Overview: Project goals and core functionality
2. Tech Stack: Technologies, libraries, frameworks with versions
3. Project Structure: File organization with explanations
4. Coding Standards: Style conventions, linting rules, patterns
5. User Stories: Key functionality from user perspective
6. APIs and Integrations: External services and connections
```

<Note>
  For architecture planning and complex design decisions, use reasoning-focused AI models. They excel at analyzing tradeoffs, edge cases, and long-term planning.
</Note>

## Effective Prompting Strategies

### Be Specific

AI tools respond best to clear, direct instructions.

❌ "Help me with my code"
✅ "Refactor this authentication function to use async/await instead of nested then() calls"

### Provide Context

**Template:**

```
I'm working on an OnchainKit project using [frameworks/libraries]. I need help with:

1. Problem: [describe specific issue]
2. Current approach: [what you've tried]
3. Constraints: [technical limitations]
4. Expected outcome: [what success looks like]

Relevant docs: @https://onchainkit.xyz

Relevant code:
[paste your code]
```

### Iterate

Start simple and refine rather than trying to get everything perfect at once.

**Template:**

```
Let's approach this step by step:
1. First, implement basic [feature] with minimal functionality
2. Review and identify improvements
3. Add error handling and edge cases
4. Optimize for performance

Start with step 1.
```

## Working with OnchainKit

### Using Documentation

Reference OnchainKit documentation directly in your prompts:

1. Browse [OnchainKit docs](../getting-started/overview)
2. Find your component
3. Reference the docs URL in your prompt

**Example:**

```
I'm implementing a swap component with OnchainKit. 

Docs: @https://onchainkit.xyz

Show me how to implement a swap that:
1. Swaps USDC to ETH on Base
2. Handles connection states
3. Includes error handling
4. Follows UX best practices
```

### Component Integration

**Token balance example:**

```
Implement a token balance display feature:

1. Shows connected wallet's balance of [TOKEN_SYMBOL]
2. Updates when balance changes
3. Handles loading and error states
4. Follows project coding standards
5. Update instructions.md with this implementation
```

## Debugging with AI

### Debugging Prompts

**Bug analysis template:**

```
I'm encountering an issue:

1. Expected behavior: [what should happen]
2. Actual behavior: [what's happening]
3. Error messages: [any errors]
4. Relevant code: [problematic code]

Analyze step by step and help me:
1. Identify potential causes
2. Suggest debugging steps
3. Propose solutions
```

**Debug logging template:**

```
Add comprehensive logging to this function to trace:
1. Input values and types
2. Function execution flow
3. Intermediate state changes
4. Output values or errors

Code:
[paste your code]
```

### When Stuck

**Clarification template:**

```
I'm unsure how to proceed with [specific task]. Here's what I know:
1. [problem context]
2. [what you've tried]
3. [specific areas needing guidance]

What additional information would help you assist better?
```

## Advanced Techniques

1. **Step-by-step reasoning**
   ```
   Analyze this code step by step and identify potential issues.
   ```

2. **Format specification**
   ```
   Structure your response as a tutorial with code examples.
   ```

3. **Length guidance**
   ```
   Provide a concise explanation in 2-3 paragraphs.
   ```

4. **Clarify ambiguities**
   ```
   You suggested two approaches. I prefer the first with TypeScript.
   ```

## Best Practices

1. **Understand context limitations** - AI has finite memory, prioritize important info
2. **Provide relevant context** - Share code, errors, and project details that matter
3. **Be specific** - Clear instructions beat vague questions
4. **Break down complex tasks** - Iterative approaches work better
5. **Request explanations** - Ask AI to explain generated code you don't understand
6. **Use clear formatting** - Structure prompts with sections
7. **Reference docs** - Include OnchainKit documentation links
8. **Test and validate** - Always review AI-generated code before implementing
9. **Build on context** - Reference earlier conversation parts when iterating
10. **Provide feedback** - Tell AI what worked and what didn't
